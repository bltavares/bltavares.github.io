#+OPTIONS: toc:nil
#+BEGIN_HTML
---
layout: post
title: Expressando o dominio atraves do sistema de tipos
tags:
- rust
- design
- fp
---
#+END_HTML
(Note: This post should be Google Translate friendly. I've refrained from using slangs to help with that.)

Algumas vezes eu conversei com algumas pessoas sobre como é possível aproveitar
o sistema de tipos para poder expressar melhor o domínio da sua aplicação.

Esse post é para que eu possa desenvolver melhor a idea e mostrar um pouco, de
forma mais prática, as vantagens de se ter um sistema de tipos (expressivo), em
relação a sistemas de tipos mais simples.

Quando eu falo sobre sistema de tipos expressivos eu me refiro a um conjunto de linguagens com algumas abstrações e conceitos um pouco fora do "mainstream".
Por isso, acho interessante a leitura de um Gist escrito pelo Gary Bernhardt sobre [[https://gist.github.com/garybernhardt/122909856b570c5c457a6cd674795a9c]["Types"]] para poder entender as diferentes aspectos de cada linguagem.

O resultado final desse post poderia ser muito bem a arquitetura implementada em outra linguagem, mesmo com um sistema de tipos como o do JavaScript, Python ou Ruby.

Sistemas de tipos mais dinamicos possuem suas vantagens, mas eu gostaria de focar nas vantagens dos tipos estáticos, sem comparar (talvez isso seja um assunto para outro post).
Eu gostaria de demonstrar um dos aspectos de um sistema de tipo mais restritivo, e como aproveitar o investimento que é "definir melhor o seu programa", mesmo que isso queira dizer um pouco mais verboso e enrigecido.

** Qual "Sistema estático" vou utilizar?

   Esse post foi pensado em Rust, que tem algumas caracteristicas um pouco peculiares, se comparados com o sistema de tipos estático mais mainstream (Java ou C#).

   - /Null/ não é um habitante de todos os /Tipos/.

     Em Java, por exemplo, a seguinte assinatura de função requer que o corpo da função seja inspecionado para descobrir se ~null~ pode ser retornado.

     #+BEGIN_SRC java
    public static class File {
        public static File open(String path) {
            //....
        }
    }
     #+END_SRC

     Em Rust, funções que poderiam retornar ~null~ ou valores não definidos precisam de ter isso declarado na sua assinatura, alertando sobre o possível problema.

     #+BEGIN_SRC rust
      mod file {
          pub fn open(path: String) -> Result<File> {
              // ....
          }
      }
     #+END_SRC

   - É possível expressar que um valor será invalidado após uma operação

   Como Rust possui o conceito de [[https://doc.rust-lang.org/book/ownership.html][propriedade do valor]], é possível definir que uma função preciso do ser dona de um valor, invalidando qualquer outra referencia, caso não seja possivel copiar ou clonar o dado.
   Isso traz mais expressividade, mas ao mesmo tempo um conceito a mais para aprender.

   Como sempre são escolhas de beneficio x valor. Vamos ver o que é possível expressar sem ler o corpo das funções.

** Dominio do problema

   Vou escolher problemas em um domínio que acontece quase sempre, mas com algumas caractrísticas arbitrárias para poder exercitar melhor os conceitos que o sistema de tipos de Rust possui.

   Estamos escrevendo um sistema de pedidos.

   - Nossos pedidos acontecem por uma API em um servidor
   - Um pedido não pode ter quantidades negativas
   - Como podemos ficar fora de estoque, em caso de erro devemos voltar ao produto com uma mensagem
     - É preciso inciar o processo todo de novo e nenhuma outra thread poderia usar nosso pedido
   - Toda transação precisa receber um token de sessão
   - Toda sessão é iniciada por um token de autorização

   Depois dessas regras arbitrárias, vamos lá ver o que é possível descrever do nosso domínio apenas pelo sistema de tipos e regras de visiblidade.
   A implementação das funções não importam no momento, vamos observar quais informações podemos tirar das assinaturas, como se estivessimos utilizando uma biblioteca de um terceiro.

** Implementação inicial

   #+BEGIN_SRC rust
   pub fn authorize(auth_token: String) -> String {
       unimplemented!()
   }

   pub fn send_order(session_token: String,
                     amount: u8,
                     product: String) {
       unimplemented!()
   }

   fn main() {
       let session_token = authorize("My initial token".into());
       send_order(session_token, 10, "Bananas".into())
   }
   #+END_SRC

   Essa é uma implementação bem inocente e inicial.

   Temos nossa função principal do problema, =send_order=, com os conceitos de quantidade, produto, token de sessão.
   Existe uma função que pode gerar um token de sessão.
   Mas de nenhuma forma estou definindo no programa que essas duas funções tem uma relação bem próximas.

   Eu poderia chamar a função =send_order= com uma /String/ arbitrária, e ter um erro de parsing, validação ou qualquer outra coisa.
   Vamos deixar nosso programa melhor definido escrevendo mais código.

** COMMENT Extraindo o conceito de Session Token

   #+BEGIN_SRC rust
     pub struct SessionToken(String);

     pub fn authorize(auth_token: String) -> SessionToken {
         unimplemented!()
     }

     pub fn send_order(session_token: SessionToken,
                       amount: u8,
                       product: String) {
         unimplemented!()
     }

     fn main() {
         let session_token = authorize("My initial token".into());
         send_order(session_token, 10, "Bananas".into())
     }
   #+END_SRC

   Sem se ater muito aos detalhes, esse novo snippet introduz uma estrutura que encapsula uma /String/.
   A nossa estrutura =SessionToken= faz a conexão entre o retorno de =authorize=
   com a entrada de =send_order=.

   Se analizarmos as assinaturas, a conexão entre as duas funções agora vai além
   dos nomes e começa a entrar no nível de estruturas de dados que o compilador
   pode verificar.

   Nosso código de uso no =main= se manteve o mesmo.
   Mas agora, programas que tentarem passar uma string arbitrária para a função =send_order= não poderam ser mais compilados.
   Menos um erro de runtime, a não ser que forçemos a criação do /SessionToken/ com uma /String/ ruim.

** Reutilizando o Session Token

   Um problema interessante acontece se tentarmos fazer dois pedidos com o código anterior:

   #+BEGIN_SRC rust
 fn main() {
     let session_token = authorize("My initial token".into());
     send_order(&session_token, 10, "Bananas".into());
     send_order(&session_token, 5, "Peras".into());
 }
   #+END_SRC

   Ao compilar o programa, temos o seguinte erro:

   #+BEGIN_SRC
 $ rustc ~/order.rs

 error[E0382]: use of moved value: `session_token`
   --> /Users/bruno/order.rs:16:16
    |
 15 |     send_order(session_token, 10, "Bananas".into());
    |                ------------- value moved here
 16 |     send_order(session_token, 5, "Peras".into());
    |                ^^^^^^^^^^^^^ value used here after move
    |
    = note: move occurs because `session_token` has type `SessionToken`, which does not implement the `Copy` trait

 error: aborting due to previous error
   #+END_SRC

   Todo essa mensagem de erro está relacionada ao conceito de [[https://doc.rust-lang.org/book/ownership.html][propriedade do valor]] que Rust tem.

   Da forma que a assinatura da nossa função está escrita, temos que enviar todo o valor, junto com a propriedade para fazer um pedido.
   O valor do token pertence a variável em /main/. Ao chamarmos a função /send_order/ pela primeira vez, esse valor é movido e perde a disponibilidade para chamarmos mais uma vez.

   Como a função /session_token/ so precisa do valor [[https://doc.rust-lang.org/book/references-and-borrowing.html][/emprestado/]],  para enviar pela rede.
   Precisamos mudar a assinatura da nossa função para demonstrar a intenção que queremos o valor emprestado, e que não vamos reescrever ou alterar o token, só vamos pegar emprestado para poder fazer o pedido.gqq:w

   A mudança é pequena na assinatura, trocando de =SessionToken= para =&SessionToken=, e corrigindo como passamos o argumento do token.
   Temos agora definido que não vamos alterar o valor da variável /session_token/
   ao chamar o /send_order/ e que um mesmo token pode ser reutilizado, inclusive
   compartilhado por várias threads ao realizar o pedido.

   #+BEGIN_SRC rust
 pub struct SessionToken(String);

 pub fn authorize(auth_token: String) -> SessionToken {
     unimplemented!()
 }

 pub fn send_order(session_token: &SessionToken,
                   amount: u8,
                   product: String) {
     unimplemented!()
 }

 fn main() {
     let session_token = authorize("My initial token".into());
     send_order(&session_token, 10, "Bananas".into());
     send_order(&session_token, 5, "Peras".into());
 }
   #+END_SRC

** Expondo apenas uma maneira de criar um Session Token válido

   Ainda lidando com o conceito de /SessionToken/, senti a necessitade te tornar o
   relacinamento entre /authorize/ e /send_order/ mais forte.

   Com o código anterior, seria bem possível criar um token inválido:

   #+BEGIN_SRC rust
  fn main() {
      send_order(SessionToken("ASDF".into()), 10, "Bananas".into());
  }
   #+END_SRC

   A estrutura /SessionToken/ tem um token inválido, o que poderia causar erros ao ser utilizado por outras APIs.
   Se utilizarmos uma restrição na visibilidade do que é exportado, podemos definir que /SessionTokens/ sejam criados só se forem válidos.

   Podemos criar um módulo no nosso arquivo, tornar as propiedados do nosso
   construtor privadas, e ter a função /authorize/ como a única função que retorna
   um /SessionToken/.

   Assim, caso o desenvolvedor queira um /SessionToken/, é preciso chamar /authorize/.
   E como /send_order/ precisa de um token, a relação entre as duas funções é mais forte e validada pelo compilador.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub fn authorize(auth_token: String) -> SessionToken {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       amount: u8,
                       product: String) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     // let s = SessionToken("ASDF".into());
     let session_token = authorize("My initial token".into());
     send_order(&session_token, 10, "Bananas".into());
     send_order(&session_token, 5, "Peras".into());
 }
   #+END_SRC

   Experimentem descomentar a linha comentada no /main/, e ver o erro.

** Extraindo o conceito de Pedido

   Uma regra do dominio que está escrita nas entrelinhas é que temos o conceito de um pedido válido.
   Deveriamos ter apenas pedidos com números positivos.

   Podemos aprender um pouco com os passos anteriores, e ir ao caminho de extrair o
   conceito de /Order/, e ter apenas uma forma de criar um /Order/, que faz as
   validações necessárias.

   Vamos precisar de alguns passos intermediários para poder chegar lá.
   Primeiro, vamos criar uma estrutura que encapsula o conceite de pedido, chamada /Order/.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct Order {
         pub amount: u8,
         pub name: String,
     }

     pub fn authorize(auth_token: String) -> SessionToken {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: &Order) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     let session_token = authorize("My initial token".into());

     let first_order = Order { amount: 10, name: "Bananas".into() };
     send_order(&session_token, &first_order);
 }
   #+END_SRC

** Restringindo o conceito de Pedido válido

   Agora com nossa estrutura sendo utilizada pelo /main/ e pelo /send_order/,
   podemos tornar parte interna da estrutura privada, tornando a função
   /create_order/ a única forma permitida para criar nossa estrutura.

   Podemos então colocar toda a regra de validações dentro da unica maneira de
   criar a estrutura requeria pela função /send_order/.

   Criamos um relacionamento forte entra a saida de /create_order/ com a entrada de
   /send_order/, assim como haviamos feito anteriormente.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub fn create_order(amount: u8, name: String) -> Order {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> SessionToken {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: &Order) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     let session_token = authorize("My initial token".into());

     let first_order = create_order(10, "Bananas".into());
     send_order(&session_token, &first_order);
 }
   #+END_SRC

** Indicando que um pedido pode ser inválido

   Uma pergunta ficou com o código anterior: O que acontece se a validação falhar?

   Como eu não posso retornar nulos (Rust não tem nulo), nem mandar exceções (Rust não tem exceções), tenho duas opções:

   1. Abortar o programa inteiro (eg: panic!)
   2. Retornar uma estrutura de dados que indica a possibilidade de falha da nossa operação

   A opção 1 é menos que o ideal. Eu não gostaria que meu programa morrese completamente apenas por ter um pedido inválido.
   Além do mais, nossas regras de nogócio possui instruções sobre o que fazer em caso de erro, logo eu preciso lidar com pedidos inválidos.

   Vamos aproveitar uma estrutura chamada [[https://doc.rust-lang.org/std/result/index.html][/Result/]] que está disponível na =stdlib= da linguagem.
   Nós poderiamos reescrever essa estrutura nós mesmos, mas já existem várias funcionalidades que ganhamos ao utilizar uma estrutura standard.

   O conceito de /Result/ é uma estrutura que tem duas variações de tipos, caso a operação tenha dado certo, temos um dos tipos.

   Um valor com tipo =Result<Order, String>= significaria que caso a operação tenha
   dado certo (Result::Ok), você poderá extrair um valor do tipo /Order/, e caso
   tenha dado errado (Result::Err), você tera um valor do tipo /String/.

   Vou aproveitar e criar uma estrutura bem específica para que possamos comunicar qual tipo de erro aconteceu ao criar nosso pedido.
   A estrututura chamada /InvalidOrder/ terá a uma mensagem de erro, e encapsula bem o domínio do possível erro na nossa função.

   Com a assinatura atualizada, sou obrigado a utilizar alguma estratégia para verificar se a estrutura foi criada.
   Vou utilizar =pattern matching=, e apenas enviar o pedido caso eu tenha um resultado =Ok= no /main/.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct InvalidOrder(String);

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> SessionToken {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: &Order) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     let session_token = authorize("My initial token".into());

     let first_order = create_order(10, "Bananas".into());

     if let Ok(order) = first_order {
         send_order(&session_token, &order);
     }
 }
   #+END_SRC

** Trazendo o mesmo de possível falha para iniciar uma sessão

   Assim como haviamos aprendido com o passo anterior, temos espaços para introduzir o conceito de possíveis falhas a funções anteriores.

   Como pedir um token de sessão involve fazer uma chamada a um outro pedido,
   podemos ter erros e falhas, que deveriam ser comunicados ao desenvolvedor, para
   que possa tomar um decisão sobre o que fazer.

   Diferente de criar um pedido, as razões de erro podem ser uma de muitas!

   Podemos ter um erro ao fazer o parsing do /JSON/, ou a nossa conexão cair.
   Vamos aproveitar e criar um =enum= para cada um dos possíveis erros que
   gostariamos de comunicar através da nossa assinatura.

   Essa mudança na assinatura também requer uma mudança no /main/.
   Como eu só posso continuar e fazer o pedido caso a autorização estaja /Ok/, vou
   utilizar a mesma estratégia de /pattern matching/ que utilizamos no resultado ao
   criar um pedido.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct InvalidOrder(String);

     pub enum TokenResponseError {
         ParsingError(String),
         IoError(String),
     }

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> Result<SessionToken, TokenResponseError> {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: &Order) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     if let Ok(session_token) = authorize("My initial token".into()) {
         let first_order = create_order(10, "Bananas".into());

         if let Ok(order) = first_order {
             send_order(&session_token, &order);
         }
     }
 }
   #+END_SRC

** Invalidando uma ordem depois que ela é enviada

   Revisando a lista de problemas que temos para resolver, temos bem claro que depois que um pedido é feito e temos um erro, deveríamos iniciar o fluxo novamente.
   Isso pode ser interpretado que assim que eu enviar o pedido, independente do resultado, eu não deveria enviar o mesmo pedido.

   Se imaginarmos que nosso código será usado em um ambiente com multi-thread, deveriamos trazer essa regra para a nossa assinatura.
   Se uma thread enviar um pedido, outra thread não poderá enviar o mesmo pedido, nem mesma a mesma thread.

   Podemos trocar a assinatura do argumento /order/ de =&Order= para =Order= para transmitir nossa intenção.

   Este é o inverso do que temos definido para o token.
   O token deveria ser compartilhado ao fazer vários pedidos. O pedido precisa não pode ser compartilhado.
   Nesse caso eu gosto de pensar que o pedido foi "consumido" por /send_order/, invalidando qualquer outra tentativa de utilizar a estrutura por outros meios.

   Na maioria dos casos, os problemas irão preferir utilizar o valor "emprestado",
   mas as nossas regras arbitrárias geraram esse cenário e gostaria de compartilhar
   um exemplo com vocês.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct InvalidOrder(String);

     pub enum TokenResponseError {
         ParsingError(String),
         IoError(String),
     }

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> Result<SessionToken, TokenResponseError> {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: Order) {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     if let Ok(session_token) = authorize("My initial token".into()) {
         let first_order = create_order(10, "Bananas".into());

         if let Ok(order) = first_order {
             send_order(&session_token, order);
             // send_order(&session_token, order);
         }
     }
 }
   #+END_SRC

** Trazendo uma resposta sobre o resultado do Pedido

   Nosso dominio traz regras sobre o que fazer em caso de erro ao fazer um pedido.
   Nossa interface deveria refletir as nossas intenções e demonstrar que existe uma resposta ao tentar fazer um pedido.

   Vamos criar uma estrutura para converter a responsta em /JSON/ para uma estrutura com os campos a serem preenchidos.
   Também vamos demonstrar que nosso envio do pedido pode falhar, assim como acontece ao iniciar uma sessão.

   #+BEGIN_SRC rust
     mod lib {
         pub struct SessionToken(String);

         pub struct InvalidOrder(String);

         pub enum ApiError {
             ParsingError(String),
             IoError(String),
         }

         pub struct Order {
             amount: u8,
             name: String,
         }

         pub struct OrderResponse {
             pub name: String,
             pub status: String,
             pub amount: u8,
         }

         pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
             if amount <= 0 {
                 unimplemented!()
             }
             unimplemented!()
         }

         pub fn authorize(auth_token: String) -> Result<SessionToken, ApiError> {
             unimplemented!()
         }

         pub fn send_order(session_token: &SessionToken,
                           order: Order) -> Result<OrderResponse, ApiError> {
             unimplemented!()
         }
     }

     pub use lib::*;

     fn main() {
         if let Ok(session_token) = authorize("My initial token".into()) {
             let first_order = create_order(10, "Bananas".into());

             if let Ok(order) = first_order {
                 send_order(&session_token, order);
             }
         }
     }
   #+END_SRC

   Uma grande vantegem de utilizar a estrutura /Result/ que vem na standard lib, é que o compilador entende a semantica de erros.
   Nosso código esta fazendo uma chamada que pode falhar ao enviar o pedido, mas nunca está checando se tudo aconteceu como esperado.

   O compilador sabe que /Result/ tem a semanta de uma operação que pode falhar, e nos avisa se não utilizamos o valor. Obrigado =rustc=.
   Vamos ignorar alguns /warnings/ do compilador, por não implementarmos nenhuma das funções e não usar nenhuma parte interna das estruturas.

   #+BEGIN_SRC
 $ rustc -A unused_variables -A dead_code ~/order.rs
 warning: unused result which must be used, #[warn(unused_must_use)] on by default
   --> ~/order.rs:46:13
    |
 46 |             send_order(&session_token, order);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   #+END_SRC

** Definindo possíveis status de um pedido

   Podemos aproveitar e definar mais ainda quais os possíveis estados um resultado de pedido pode estar.

   Ao invés de aceitar qualquer tipo de /String/, podemos criar um =enum= com todos os possíveis estados que nos importamos.
   Isso torna nosso modelo mais expressivo, e como consumidor, não precisamos nos
   preocupar se devemos utilizar números, strings em minúsculo, strings em
   maiúsculo, capitalizadas, etc.

   Além de tornar o nosso modelo mais expressivo, permitindo que alguém que esteja
   explorando a documentação saiba os possíveis estados, permite que o compilador
   verifica exaustivamente pattern matchings em cima do estado, e delega a
   responsabilidade de transformar os valóres a serem transmitidos e parseados para
   a parte que faz a comunicação no programa.

   Vamos introduzir a estrutura /OrderStatus/.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct InvalidOrder(String);

     pub enum ApiError {
         ParsingError(String),
         IoError(String),
     }

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub struct OrderResponse {
         pub name: String,
         pub status: OrderStatus,
         pub amount: u8,
     }

     pub enum OrderStatus {
         Waiting,
         Shipping,
         Shipped,
         Delivered,
     }

     pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> Result<SessionToken, ApiError> {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: Order) -> Result<OrderResponse, ApiError> {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     if let Ok(session_token) = authorize("My initial token".into()) {
         let first_order = create_order(10, "Bananas".into());

         if let Ok(order) = first_order {
             send_order(&session_token, order);
         }
     }
 }
   #+END_SRC

** Dando um nome mais bonito para nossas respostas da API

   Assim que começarmos a criar mais e mais funções que utilizão comunição com
   nossa API, veremos o tipo =Result<T, ApiError>=, várias e várias vezes.

   Podemos criar um tipo =ApiRespose= para que todos saibam que essa é uma chamada
   para a API, e que todas as respostas que tem esse tipo, terão os mesmo possíveis
   erros para se preocupar.

   #+BEGIN_SRC rust
 mod lib {
     pub struct SessionToken(String);

     pub struct InvalidOrder(String);

     pub enum ApiError {
         ParsingError(String),
         IoError(String),
     }

     pub struct Order {
         amount: u8,
         name: String,
     }

     pub struct OrderResponse {
         name: String,
         status: OrderStatus,
         amount: u8,
     }

     pub enum OrderStatus {
         Waiting,
         Shipping,
         Shipped,
         Delivered,
     }

     pub type ApiResponse<T> = Result<T, ApiError>;

     pub fn create_order(amount: u8, name: String) -> Result<Order, InvalidOrder> {
         if amount <= 0 {
             unimplemented!()
         }
         unimplemented!()
     }

     pub fn authorize(auth_token: String) -> ApiResponse<SessionToken> {
         unimplemented!()
     }

     pub fn send_order(session_token: &SessionToken,
                       order: Order) -> ApiResponse<OrderResponse> {
         unimplemented!()
     }
 }

 pub use lib::*;

 fn main() {
     if let Ok(session_token) = authorize("My initial token".into()) {
         let first_order = create_order(10, "Bananas".into());

         if let Ok(order) = first_order {
             send_order(&session_token, order);
         }
     }
 }
   #+END_SRC

** Conclusão
   O resultado do nosso programa está bem mais definido do que inicamos, mas bem maior ao mesmo tempo.
   Trocamos verbosidade e tamanho de código por um programa mais bem definido e expressando melhor nosso domínio.

   Algumas categorias de erro, como passar um token inválido ao fazer o pedido, foram completamente removidos.

   Mesmo sem escrever a implementação dos nosso metodos, podemos extrair algumas
   informações sobre nosso dominio. Saber extrair e definir essas informações e
   intenções também é uma prática a ser explorada pelos desenvolvedores.

   Esse resultado final não está tão idiomático e pode melhorar. Mas já temos o
   suficiente para explorar a expressividade de um sistema de tipos estáticos
   como o de Rust.

   Como não cheguei a implementar o corpo das funções e quis apenas focar na
   informação que a assinatura convem, não cheguei a explorar como TDD pode nos
   ajudar a evoluir nosso design. Isso pode ser material para oturo post.

   Espero que tenha gostado da idea e que explorem melhor. Me enviem um
   post-resposta para discutirmos mais.
