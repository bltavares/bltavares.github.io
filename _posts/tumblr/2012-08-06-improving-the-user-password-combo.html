---
layout: post
title: Improving the user/password combo
tags: 
---
<p>Hi there!</p>

<p>I&#8217;ve been playing around with cryptography and security, and every time I stumble on asymmetric keys I get amazed! All my deployments rely on it.</p>
<p>All my connections to another machine rely on the identity provided by my private key.</p>

<p>We have been building our identity on the internet. And we don&#8217;t like to let other people impersonate you. That is <em>YOU, </em>nobody can be you!</p>

<p>That is why we set up a password for our online services. That is why we have PGP signatures. But it is boring to remember passwords all the time.</p>

<p>Some initiatives have been done to address this issue, like OpenID, OAuth and password managers. I really like how OAuth provides a user identity and restricts usage of these identities, giving you the choice to allow them to do some actions in your name. I like the way OpenID provides an online identity, identifying the user to a profile. And I think the way 1Password integrates with the browser is awesome.</p>
<p>Mozilla is doing an interesting experiment, <a href="http://www.mozilla.org/en-US/persona/">Mozilla Persona</a>, to provide some of the OpenID benefits through the browser.</p>

<p>And then, asymmetric keys always come to my mind.  This magic way of telling any other user that I am the right &#8216;Bruno&#8217; by using a secure key. Some companies already use that authentication format to deploy code, upload files, and store data.</p>

<p>I&#8217;ve been thinking different ways to use the power of PGP to identify myself on websites. With the right implementation we could give the user the choice to not user a password at all!</p>

<p>The most recent idea I had is something like this:</p>
<ul><li>Manage your PGP keys using subkeys. (Keep your master key completely <em>SECURE</em>). That way, if any of your keys get compromised, you still can revoke access to it and restore your user identity.</li>
</ul><div></div>
<ul><li>Using a challenge-response method in a two way encryptation. The service provider sends a encrypted random message, that should be decrypted by you, and then, respond encrypting with the server public key. It would secure the user authentication on another level, by proving the current website is the correct one, not a fake server.</li>
</ul><div></div>
<ul><li>A browser/desktop/mobile API, so that you don&#8217;t need have too much hassle responding to the challenge. It could be also a kind of local OAuth provider, in a way that you could choose what the provider could do in your name.</li>
</ul><p>We don&#8217;t need to get rid of the password login, but we could add a small advanced login link on the registration/security form, which you could provide the initial public key to access your computer.</p>
<p><img src="http://media.tumblr.com/tumblr_m8d0p8mbbJ1qamcq2.png"/></p>
<blockquote>
<p>I would like to see something like this.</p>
</blockquote>
<p>The implementation still have some flaws, and I am thinking ways to implement it at the same time I am writing this post. That is the initial draft I have for now.</p>

<p>I would like to, some day, use my private key to login in on Twitter.</p>
